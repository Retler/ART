package processing

import (
	"bufio"
	"encoding/json"
	"errors"
	"fmt"
	config "github.com/Retler/ART/config"
	repo "github.com/Retler/ART/tweet_repo"
	tweets "github.com/Retler/ART/tweets"
	"github.com/grassmudhorses/vader-go/lexicon"
	"github.com/grassmudhorses/vader-go/sentitext"
	"io"
	"net/http"
)

// Used by TweetProducer to send errors and shutdown notifications to the main thread
type Result struct {
	Message string
	Error   error
}

// TweetProducer is responsible for listening to the Twitter 1% sample API
// It will receive, parse and push the Tweets onto the TweetQueue for consumption
type TweetProducer struct {
	Config      config.Config
	TweetQueue  chan tweets.Tweet
	ResultQueue chan Result
	Client      tweets.HttpClient
}

// TweetConsumer is responsible for consuming Tweets generated by TweetProducer
// "Consumption" can mean various things. The sink of the Tweets can be either memory
// or some database. Furthermore, caching can be introduced to avoid many writes.
type TweetConsumer interface {
	StartConsuming()
}

// TweetConsumerMemory consumes tweet to a memory tweet_id:tweet map
type TweetConsumerSimple struct {
	TweetQueue  chan tweets.Tweet
	ResultQueue chan Result
	TweetRepo   repo.TweetRepository
}

// Start reading tweets from the channel.
// Tweets may be enhanced with additional information. Non-english tweets are sorted out.
func (t *TweetConsumerSimple) StartConsuming() {
	for tweet := range t.TweetQueue {
		if tweet.Data.Language != "en" { // Only save english tweets
			continue
		}

		sentiment := GetSentiment(tweet.Data.Content)
		tweet.Sentiment = sentiment

		err := t.TweetRepo.SaveTweet(tweet)
		if err != nil {
			t.ResultQueue <- Result{
				Message: "Error saving tweet",
				Error:   err,
			}
		} else {
			t.ResultQueue <- Result{
				Message: "Saved tweet!",
				Error:   nil,
			}
		}

	}

	t.Shutdown("Tweet channel closed. Done consuming Tweets", nil)
}

func (t *TweetConsumerSimple) Shutdown(message string, err error) {
	t.ResultQueue <- Result{
		Message: message,
		Error:   err,
	}
	close(t.ResultQueue)
}

func GetSentiment(text string) float64 {
	parsedtext := sentitext.Parse(text, lexicon.DefaultLexicon)
	sentiment := sentitext.PolarityScore(parsedtext)
	return sentiment.Compound
}

// TweetProducer is designed to be the only "Producer" of tweets with multiple consumers
// Therefore it is safe to let it close the channels on shutdown
func (t *TweetProducer) Shutdown(message string, err error) {
	t.ResultQueue <- Result{
		Message: message,
		Error:   err,
	}
	close(t.ResultQueue)
	close(t.TweetQueue)
}

// Starts streaming and parsing of Tweets from the sample API
// Should be used as a goroutine. On any errors, the routine will communicate on the 'done' channel
// and gracefully close
// TODO: implement recovery logic (exponential backoff or similar) on connection resets
func (t *TweetProducer) StartStreaming() {
	url := t.Client.Url()
	req, err := http.NewRequest("GET", url, nil)

	// Shutdown producer on request creation failure
	if err != nil {
		t.Shutdown("Could not create request", err)
		return
	}

	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", t.Config.BearerToken))

	resp, err := t.Client.Do(req)
	defer resp.Body.Close()

	// Shutdown producer on request execution failure
	if err != nil {
		t.Shutdown("Failed to execute request", err)
		return
	}

	// Shutdown producer on bad status code (TODO: implement recovery logic based on status)
	if resp.StatusCode != http.StatusOK {
		err = errors.New(fmt.Sprintf("Wrong response status code when fetching tweets: %d", resp.StatusCode))

		t.Shutdown("Response status not OK", err)
		return
	}

	reader := bufio.NewReader(resp.Body)
	for {
		line, errReader := reader.ReadBytes('\n')

		// Shutdown producer on bad response body
		if errReader != nil && errReader != io.EOF {
			t.Shutdown("Could not read response body", errReader)
			break
		}

		tweet := tweets.Tweet{}
		err = json.Unmarshal([]byte(line), &tweet)

		// Shutdown producer if tweets cannot be parsed
		// TODO: take care of other kinds of messages that Twitter API can send on the stream
		if err != nil {
			t.ResultQueue <- Result{
				Message: fmt.Sprintf("Could not parse tweet: %v\nContinuing...", line),
				Error:   err,
			}
			continue
		}

		t.TweetQueue <- tweet

		if errReader == io.EOF { // Reached end of stream, send last Tweet and shut down
			t.Shutdown("Reached EOF in stream", errReader)
			break
		}

	}
}
